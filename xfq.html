<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ¢¦ç¾½çš„å°ç•ªèŒ„å›¾ç‰‡æ··æ·†</title>
<!-- EXIF å¤„ç†åº“ -->
<script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Microsoft YaHei', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: #333;
}

.container {
    width: 100%;
    max-width: 900px;
    text-align: center;
}

.card {
    background: rgba(255, 255, 255, 0.98);
    border-radius: 24px;
    padding: 40px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
}

h1 {
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 20px;
    letter-spacing: 1px;
}

.description {
    max-width: 600px;
    margin: 0 auto 40px;
    color: #666;
    font-size: 1rem;
    line-height: 1.8;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 12px;
    border-left: 4px solid #667eea;
}

.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 40px;
}

.normal_button {
    min-width: 120px;
    height: 48px;
    line-height: 48px;
    font-size: 1rem;
    padding: 0 24px;
    border: none;
    border-radius: 12px;
    display: inline-block;
    position: relative;
    vertical-align: middle;
    color: #fff;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    overflow: hidden;
}

.normal_button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.normal_button:hover::before {
    transform: translateX(100%);
}

.normal_button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.normal_button:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.btn-select {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.btn-paste {
    background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
}

.btn-encrypt {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

.btn-decrypt {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

.btn-restore {
    background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
}

.btn-ai-site {
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
    color: #333 !important;
}

.ipt_btn {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.image-container {
    background: #f8f9fa;
    border-radius: 16px;
    padding: 20px;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px dashed #dee2e6;
    transition: all 0.3s ease;
}

.image-container.has-image {
    border-color: #667eea;
    background: #fff;
}

.image-container.drag-over {
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.1);
    transform: scale(1.02);
}

#display-img {
    max-width: 100%;
    max-height: 60vh;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
}

#display-img:hover {
    transform: scale(1.02);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}

.empty-state {
    color: #adb5bd;
    font-size: 1.1rem;
}

.processing-state {
    color: #667eea;
    font-size: 1.1rem;
    font-weight: 600;
    display: none;
}

.processing-state::after {
    content: '...';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

.settings-panel {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    border: 1px solid #dee2e6;
}

.settings-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: #495057;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.radio-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: #fff;
    border: 2px solid transparent;
}

.radio-option:hover {
    background: #f8f9fa;
    border-color: #667eea;
}

.radio-option input[type="radio"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #667eea;
}

.radio-option label {
    cursor: pointer;
    font-size: 0.95rem;
    color: #495057;
    user-select: none;
}

.radio-option input[type="radio"]:checked + label {
    color: #667eea;
    font-weight: 600;
}

@media (max-width: 768px) {
    .card {
        padding: 24px;
    }

    h1 {
        font-size: 2rem;
    }

    .description {
        font-size: 0.9rem;
        padding: 15px;
    }

    .button-group {
        gap: 10px;
    }

    .normal_button {
        min-width: 100px;
        height: 44px;
        line-height: 44px;
        font-size: 0.9rem;
        padding: 0 16px;
    }
}

/* åŠ è½½åŠ¨ç”» */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.card {
    animation: fadeIn 0.6s ease;
}

/* åˆ®åˆ®ä¹æ•ˆæœæ ·å¼ */
.scratch-container {
    position: relative;
    display: inline-block;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    max-width: 100%;
    max-height: 60vh;
}

.scratch-canvas {
    position: absolute;
    top: 0;
    left: 0;
    cursor: crosshair;
    z-index: 10;
    touch-action: none;
}

.scratch-image {
    display: block;
    max-width: 100%;
    max-height: 60vh;
    border-radius: 12px;
}

.scratch-hint {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 15px 30px;
    border-radius: 12px;
    font-size: 1.2rem;
    font-weight: 600;
    pointer-events: none;
    z-index: 5;
    animation: pulse 2s infinite;
    white-space: nowrap;
}

@keyframes pulse {
    0%, 100% {
        opacity: 0.8;
        transform: translate(-50%, -50%) scale(1);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.05);
    }
}
</style>
</head>
<body>
<div class="container">
    <div class="card">
        <h1>ğŸ… æ¢¦ç¾½çš„å°ç•ªèŒ„å›¾ç‰‡æ··æ·†v2.0</h1>

        <div class="settings-panel">
            <div class="settings-title">âš™ï¸ è‡ªåŠ¨å¤„ç†è®¾ç½®</div>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="auto-none" name="auto-action" value="none" checked>
                    <label for="auto-none">ä¸å¤„ç†</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="auto-encrypt" name="auto-action" value="encrypt">
                    <label for="auto-encrypt">ğŸ”’ è‡ªåŠ¨æ··æ·†</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="auto-decrypt" name="auto-action" value="decrypt">
                    <label for="auto-decrypt">ğŸ”“ è‡ªåŠ¨è§£æ··æ·†</label>
                </div>
            </div>
        </div>

        <div class="settings-panel">
            <div class="settings-title">ğŸ¨ è§£å¯†æ˜¾ç¤ºæ¨¡å¼</div>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="display-direct" name="display-mode" value="direct">
                    <label for="display-direct">ç›´æ¥æ˜¾ç¤º</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="display-scratch" name="display-mode" value="scratch" checked>
                    <label for="display-scratch">ğŸ« åˆ®åˆ®ä¹æ•ˆæœ</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="display-scratch-transparent" name="display-mode" value="scratch-transparent">
                    <label for="display-scratch-transparent">âœ¨ åŠé€æ˜åˆ®åˆ®ä¹</label>
                </div>
            </div>
        </div>

        <div class="button-group">
            <span class="normal_button btn-select">
                ğŸ“ é€‰æ‹©å›¾ç‰‡
                <input type="file" accept="image/*" id="ipt" class="ipt_btn" />
            </span>
            <button id="paste" class="normal_button btn-paste">ğŸ“‹ ç²˜è´´å›¾ç‰‡</button>
            <button id="enc" class="normal_button btn-encrypt">ğŸ”’ æ··æ·†</button>
            <button id="dec" class="normal_button btn-decrypt">ğŸ”“ è§£æ··æ·†</button>
            <button id="re" class="normal_button btn-restore">â†» è¿˜åŸ</button>
            <button id="ai-site" class="normal_button btn-ai-site">ğŸ¨ æ‰“å¼€æ¢¦ç¾½çš„AIç”»å›¾ç«™</button>
        </div>

        <div class="image-container" id="img-container">
            <img id="display-img" style="display: none;" />
            <div class="empty-state" id="empty-state">
                æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ / ç‚¹å‡»é€‰æ‹© / æŒ‰ Ctrl+V ç²˜è´´<br>
                <small style="opacity: 0.7;">æ”¯æŒæ‹–æ”¾ã€å‰ªåˆ‡æ¿ç²˜è´´ã€æ–‡ä»¶é€‰æ‹©</small>
            </div>
            <div class="processing-state" id="processing-state">æ­£åœ¨å¤„ç†å›¾ç‰‡</div>
        </div>
    </div>
</div>
<script>
function gilbert2d(width, height) {
    /**
     * Generalized Hilbert ('gilbert') space-filling curve for arbitrary-sized
     * 2D rectangular grids. Generates discrete 2D coordinates to fill a rectangle
     * of size (width x height).
     */
    const coordinates = [];

    if (width >= height) {
        generate2d(0, 0, width, 0, 0, height, coordinates);
    } else {
        generate2d(0, 0, 0, height, width, 0, coordinates);
    }

    return coordinates;
}

function generate2d(x, y, ax, ay, bx, by, coordinates) {
    const w = Math.abs(ax + ay);
    const h = Math.abs(bx + by);

    const dax = Math.sign(ax), day = Math.sign(ay); // unit major direction
    const dbx = Math.sign(bx), dby = Math.sign(by); // unit orthogonal direction

    if (h === 1) {
        // trivial row fill
        for (let i = 0; i < w; i++) {
            coordinates.push([x, y]);
            x += dax;
            y += day;
        }
        return;
    }

    if (w === 1) {
        // trivial column fill
        for (let i = 0; i < h; i++) {
            coordinates.push([x, y]);
            x += dbx;
            y += dby;
        }
        return;
    }

    let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
    let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);

    const w2 = Math.abs(ax2 + ay2);
    const h2 = Math.abs(bx2 + by2);

    if (2 * w > 3 * h) {
        if ((w2 % 2) && (w > 2)) {
            // prefer even steps
            ax2 += dax;
            ay2 += day;
        }

        // long case: split in two parts only
        generate2d(x, y, ax2, ay2, bx, by, coordinates);
        generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);

    } else {
        if ((h2 % 2) && (h > 2)) {
            // prefer even steps
            bx2 += dbx;
            by2 += dby;
        }

        // standard case: one step up, one long horizontal, one step down
        generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
        generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
        generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
            -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
    }
}
</script>
<script>
let img = document.getElementById("display-img")
const imgContainer = document.getElementById("img-container")
let emptyState = document.getElementById("empty-state")
let processingState = document.getElementById("processing-state")

// å­˜å‚¨åŸå§‹å›¾ç‰‡çš„ EXIF æ•°æ®å’Œ PNG å…ƒæ•°æ®
let originalExifData = null
let originalPngMetadata = null
let originalImageFormat = 'jpeg' // è®°å½•åŸå§‹å›¾ç‰‡æ ¼å¼

// ä» Blob/File ä¸­æå– PNG å…ƒæ•°æ®ï¼ˆtEXt chunksï¼‰
async function extractPngMetadata(blob) {
    try {
        const arrayBuffer = await blob.arrayBuffer()
        const bytes = new Uint8Array(arrayBuffer)

        // æ£€æŸ¥ PNG æ–‡ä»¶ç­¾å
        if (bytes[0] !== 0x89 || bytes[1] !== 0x50 || bytes[2] !== 0x4E || bytes[3] !== 0x47) {
            console.log('ä¸æ˜¯ PNG æ ¼å¼ï¼Œè·³è¿‡ PNG å…ƒæ•°æ®æå–')
            originalImageFormat = 'jpeg'
            return null
        }

        originalImageFormat = 'png'
        const metadata = {}
        let offset = 8 // è·³è¿‡ PNG ç­¾å

        while (offset < bytes.length) {
            // è¯»å–å—é•¿åº¦
            const length = (bytes[offset] << 24) | (bytes[offset + 1] << 16) |
                          (bytes[offset + 2] << 8) | bytes[offset + 3]
            offset += 4

            // è¯»å–å—ç±»å‹
            const type = String.fromCharCode(bytes[offset], bytes[offset + 1],
                                            bytes[offset + 2], bytes[offset + 3])
            offset += 4

            // å¦‚æœæ˜¯ tEXt æˆ– iTXt å—ï¼Œæå–æ•°æ®
            if (type === 'tEXt' || type === 'iTXt') {
                const chunkData = bytes.slice(offset, offset + length)
                let keyword = ''
                let text = ''
                let i = 0

                // è¯»å–å…³é”®å­—ï¼ˆä»¥ null ç»“å°¾ï¼‰
                while (i < chunkData.length && chunkData[i] !== 0) {
                    keyword += String.fromCharCode(chunkData[i])
                    i++
                }
                i++ // è·³è¿‡ null åˆ†éš”ç¬¦

                // è¯»å–æ–‡æœ¬å†…å®¹
                if (type === 'tEXt') {
                    // tEXt: ç›´æ¥è¯»å– Latin-1 æ–‡æœ¬
                    const decoder = new TextDecoder('latin1')
                    text = decoder.decode(chunkData.slice(i))
                } else if (type === 'iTXt') {
                    // iTXt: è·³è¿‡å‹ç¼©æ ‡å¿—ã€å‹ç¼©æ–¹æ³•ã€è¯­è¨€æ ‡ç­¾ã€ç¿»è¯‘å…³é”®å­—
                    i++ // å‹ç¼©æ ‡å¿—
                    i++ // å‹ç¼©æ–¹æ³•
                    while (i < chunkData.length && chunkData[i] !== 0) i++ // è¯­è¨€æ ‡ç­¾
                    i++
                    while (i < chunkData.length && chunkData[i] !== 0) i++ // ç¿»è¯‘å…³é”®å­—
                    i++
                    const decoder = new TextDecoder('utf-8')
                    text = decoder.decode(chunkData.slice(i))
                }

                metadata[keyword] = text
            }

            offset += length + 4 // è·³è¿‡æ•°æ®å’Œ CRC

            // å¦‚æœé‡åˆ° IEND å—ï¼Œåœæ­¢
            if (type === 'IEND') break
        }

        if (Object.keys(metadata).length > 0) {
            console.log('æå–åˆ° PNG å…ƒæ•°æ®:', metadata)
            return metadata
        }

        console.log('PNG æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ° tEXt å…ƒæ•°æ®')
        return null
    } catch (err) {
        console.error('æå– PNG å…ƒæ•°æ®å¤±è´¥:', err)
        return null
    }
}

// æå–å›¾ç‰‡çš„ EXIF æ•°æ®
function extractExifData(imgElement) {
    return new Promise((resolve) => {
        if (typeof EXIF === 'undefined') {
            console.warn('EXIF åº“æœªåŠ è½½')
            resolve(null)
            return
        }

        EXIF.getData(imgElement, function() {
            try {
                const allMetaData = EXIF.getAllTags(this)
                if (Object.keys(allMetaData).length > 0) {
                    console.log('æå–åˆ° EXIF æ•°æ®:', allMetaData)
                    resolve(allMetaData)
                } else {
                    console.log('å›¾ç‰‡æ²¡æœ‰ EXIF æ•°æ®')
                    resolve(null)
                }
            } catch (err) {
                console.error('æå– EXIF å¤±è´¥:', err)
                resolve(null)
            }
        })
    })
}

// å°† PNG å…ƒæ•°æ®æ³¨å…¥åˆ° PNG æ•°æ®ä¸­
async function injectPngMetadata(pngBlob, metadata) {
    if (!metadata || Object.keys(metadata).length === 0) {
        return pngBlob
    }

    try {
        const arrayBuffer = await pngBlob.arrayBuffer()
        const bytes = new Uint8Array(arrayBuffer)

        // åˆ›å»º tEXt å—çš„å‡½æ•°
        function createTextChunk(keyword, text) {
            const encoder = new TextEncoder()
            const keywordBytes = encoder.encode(keyword)
            const textBytes = encoder.encode(text)
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length)

            chunkData.set(keywordBytes, 0)
            chunkData[keywordBytes.length] = 0 // null åˆ†éš”ç¬¦
            chunkData.set(textBytes, keywordBytes.length + 1)

            // åˆ›å»ºå®Œæ•´çš„å—ï¼šé•¿åº¦ + ç±»å‹ + æ•°æ® + CRC
            const chunk = new Uint8Array(4 + 4 + chunkData.length + 4)
            const view = new DataView(chunk.buffer)

            // é•¿åº¦
            view.setUint32(0, chunkData.length, false)

            // ç±»å‹ "tEXt"
            chunk[4] = 116 // 't'
            chunk[5] = 69  // 'E'
            chunk[6] = 88  // 'X'
            chunk[7] = 116 // 't'

            // æ•°æ®
            chunk.set(chunkData, 8)

            // CRC
            const crc = calculateCRC(chunk.slice(4, 8 + chunkData.length))
            view.setUint32(8 + chunkData.length, crc, false)

            return chunk
        }

        // CRC32 è®¡ç®—
        function calculateCRC(data) {
            let crc = 0xFFFFFFFF
            for (let i = 0; i < data.length; i++) {
                crc = crc ^ data[i]
                for (let j = 0; j < 8; j++) {
                    crc = (crc >>> 1) ^ ((crc & 1) ? 0xEDB88320 : 0)
                }
            }
            return (crc ^ 0xFFFFFFFF) >>> 0
        }

        // æ‰¾åˆ° IDAT å—çš„ä½ç½®ï¼ˆåœ¨å®ƒä¹‹å‰æ’å…¥ tEXt å—ï¼‰
        let idatOffset = 8
        while (idatOffset < bytes.length) {
            const type = String.fromCharCode(bytes[idatOffset + 4], bytes[idatOffset + 5],
                                            bytes[idatOffset + 6], bytes[idatOffset + 7])
            if (type === 'IDAT') break

            const length = (bytes[idatOffset] << 24) | (bytes[idatOffset + 1] << 16) |
                          (bytes[idatOffset + 2] << 8) | bytes[idatOffset + 3]
            idatOffset += 4 + 4 + length + 4
        }

        // æ„å»ºæ–°çš„ PNG
        const textChunks = []
        for (const [keyword, text] of Object.entries(metadata)) {
            textChunks.push(createTextChunk(keyword, text))
        }

        const totalTextLength = textChunks.reduce((sum, chunk) => sum + chunk.length, 0)
        const newBytes = new Uint8Array(bytes.length + totalTextLength)

        // å¤åˆ¶ PNG å¤´å’Œ IHDR ç­‰å—
        newBytes.set(bytes.slice(0, idatOffset), 0)

        // æ’å…¥ tEXt å—
        let offset = idatOffset
        for (const chunk of textChunks) {
            newBytes.set(chunk, offset)
            offset += chunk.length
        }

        // å¤åˆ¶å‰©ä½™éƒ¨åˆ†ï¼ˆIDAT å’Œåç»­å—ï¼‰
        newBytes.set(bytes.slice(idatOffset), offset)

        console.log('PNG å…ƒæ•°æ®å·²æ³¨å…¥')
        return new Blob([newBytes], { type: 'image/png' })
    } catch (err) {
        console.error('æ³¨å…¥ PNG å…ƒæ•°æ®å¤±è´¥:', err)
        return pngBlob
    }
}

// ä» Data URL ä¸­æå– EXIF æ•°æ®å¹¶æ³¨å…¥åˆ°æ–°å›¾ç‰‡
function injectExifToDataUrl(dataUrl, exifData) {
    if (!exifData || typeof piexif === 'undefined') {
        return dataUrl
    }

    try {
        // ä»åŸå§‹ EXIF æ•°æ®æ„å»º piexif æ ¼å¼çš„æ•°æ®
        const exifObj = {
            "0th": {},
            "Exif": {},
            "GPS": {},
            "Interop": {},
            "1st": {},
            "thumbnail": null
        }

        // ä¿ç•™å¸¸è§çš„ EXIF å­—æ®µ
        if (exifData.Make) exifObj["0th"][piexif.ImageIFD.Make] = exifData.Make
        if (exifData.Model) exifObj["0th"][piexif.ImageIFD.Model] = exifData.Model
        if (exifData.Software) exifObj["0th"][piexif.ImageIFD.Software] = exifData.Software
        if (exifData.DateTime) exifObj["0th"][piexif.ImageIFD.DateTime] = exifData.DateTime
        if (exifData.Artist) exifObj["0th"][piexif.ImageIFD.Artist] = exifData.Artist
        if (exifData.Copyright) exifObj["0th"][piexif.ImageIFD.Copyright] = exifData.Copyright

        // Exif å­—æ®µ
        if (exifData.DateTimeOriginal) exifObj["Exif"][piexif.ExifIFD.DateTimeOriginal] = exifData.DateTimeOriginal
        if (exifData.DateTimeDigitized) exifObj["Exif"][piexif.ExifIFD.DateTimeDigitized] = exifData.DateTimeDigitized
        if (exifData.ExposureTime) exifObj["Exif"][piexif.ExifIFD.ExposureTime] = exifData.ExposureTime
        if (exifData.FNumber) exifObj["Exif"][piexif.ExifIFD.FNumber] = exifData.FNumber
        if (exifData.ISO) exifObj["Exif"][piexif.ExifIFD.ISOSpeedRatings] = exifData.ISO
        if (exifData.FocalLength) exifObj["Exif"][piexif.ExifIFD.FocalLength] = exifData.FocalLength
        if (exifData.LensModel) exifObj["Exif"][piexif.ExifIFD.LensModel] = exifData.LensModel

        // GPS æ•°æ®
        if (exifData.GPSLatitude) exifObj["GPS"][piexif.GPSIFD.GPSLatitude] = exifData.GPSLatitude
        if (exifData.GPSLongitude) exifObj["GPS"][piexif.GPSIFD.GPSLongitude] = exifData.GPSLongitude

        const exifBytes = piexif.dump(exifObj)
        const newDataUrl = piexif.insert(exifBytes, dataUrl)
        console.log('EXIF æ•°æ®å·²æ³¨å…¥åˆ°æ–°å›¾ç‰‡')
        return newDataUrl
    } catch (err) {
        console.error('æ³¨å…¥ EXIF å¤±è´¥:', err)
        return dataUrl
    }
}

// æ˜¾ç¤ºå¤„ç†çŠ¶æ€
function showProcessing() {
    const currentImg = document.getElementById("display-img")
    const currentEmpty = document.getElementById("empty-state")
    const currentProcessing = document.getElementById("processing-state")

    if (currentImg) currentImg.style.display = "none"
    if (currentEmpty) currentEmpty.style.display = "none"
    if (currentProcessing) currentProcessing.style.display = "block"
    imgContainer.classList.add("has-image")
}

// éšè—å¤„ç†çŠ¶æ€
function hideProcessing() {
    const currentProcessing = document.getElementById("processing-state")
    if (currentProcessing) currentProcessing.style.display = "none"
}

// è·å–å½“å‰é€‰ä¸­çš„è‡ªåŠ¨å¤„ç†é€‰é¡¹
function getAutoAction() {
    const selected = document.querySelector('input[name="auto-action"]:checked')
    return selected ? selected.value : 'none'
}

// è·å–å½“å‰é€‰ä¸­çš„æ˜¾ç¤ºæ¨¡å¼
function getDisplayMode() {
    const selected = document.querySelector('input[name="display-mode"]:checked')
    return selected ? selected.value : 'direct'
}

// åˆ®åˆ®ä¹æ•ˆæœå®ç°
function createScratchEffect(imageBlob) {
    // æ¸…ç©ºå›¾ç‰‡å®¹å™¨
    imgContainer.innerHTML = ''

    // åˆ›å»ºåˆ®åˆ®ä¹å®¹å™¨
    const scratchContainer = document.createElement('div')
    scratchContainer.className = 'scratch-container'

    // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
    const scratchImg = document.createElement('img')
    scratchImg.className = 'scratch-image'
    scratchImg.src = URL.createObjectURL(imageBlob)

    // åˆ›å»ºç”»å¸ƒï¼ˆé®ç½©å±‚ï¼‰
    const canvas = document.createElement('canvas')
    canvas.className = 'scratch-canvas'

    // åˆ›å»ºæç¤ºæ–‡å­—
    const hint = document.createElement('div')
    hint.className = 'scratch-hint'
    hint.textContent = 'ğŸ‘† æ»‘åŠ¨é¼ æ ‡åˆ®å¼€æŸ¥çœ‹å›¾ç‰‡'

    // ç»„è£…å…ƒç´ 
    scratchContainer.appendChild(scratchImg)
    scratchContainer.appendChild(canvas)
    scratchContainer.appendChild(hint)
    imgContainer.appendChild(scratchContainer)
    imgContainer.classList.add('has-image')

    // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆååˆå§‹åŒ–ç”»å¸ƒ
    scratchImg.onload = () => {
        const rect = scratchImg.getBoundingClientRect()
        canvas.width = scratchImg.naturalWidth
        canvas.height = scratchImg.naturalHeight
        canvas.style.width = scratchImg.offsetWidth + 'px'
        canvas.style.height = scratchImg.offsetHeight + 'px'

        const ctx = canvas.getContext('2d')

        // ç»˜åˆ¶é®ç½©å±‚ - é“¶è‰²åˆ®åˆ®ä¹æ•ˆæœ
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height)
        gradient.addColorStop(0, '#c0c0c0')
        gradient.addColorStop(0.5, '#e0e0e0')
        gradient.addColorStop(1, '#a8a8a8')
        ctx.fillStyle = gradient
        ctx.fillRect(0, 0, canvas.width, canvas.height)

        // æ·»åŠ çº¹ç†æ•ˆæœ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'
        for (let i = 0; i < canvas.height; i += 4) {
            ctx.fillRect(0, i, canvas.width, 2)
        }

        // æ·»åŠ æ–‡å­—æç¤ºåœ¨é®ç½©ä¸Š
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'
        ctx.font = `bold ${canvas.width / 15}px Arial`
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.fillText('åˆ®å¼€æŸ¥çœ‹', canvas.width / 2, canvas.height / 2)

        ctx.globalCompositeOperation = 'destination-out'

        let isDrawing = false
        let lastX = 0
        let lastY = 0

        // è®¡ç®—åˆ®å¼€ç™¾åˆ†æ¯”
        function calculateScratchPercentage() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
            let transparent = 0
            for (let i = 3; i < imageData.data.length; i += 4) {
                if (imageData.data[i] === 0) transparent++
            }
            return (transparent / (canvas.width * canvas.height)) * 100
        }

        // ç»˜åˆ¶åˆ®ç—•
        function scratch(x, y) {
            const scale = canvas.width / canvas.offsetWidth
            const scaledX = x * scale
            const scaledY = y * scale

            ctx.beginPath()
            ctx.arc(scaledX, scaledY, 30, 0, Math.PI * 2)
            ctx.fill()

            // æ£€æŸ¥åˆ®å¼€ç™¾åˆ†æ¯”
            if (calculateScratchPercentage() > 50) {
                // è¶…è¿‡50%è‡ªåŠ¨æ¸…é™¤å…¨éƒ¨é®ç½©
                canvas.style.transition = 'opacity 0.5s ease'
                canvas.style.opacity = '0'
                hint.style.transition = 'opacity 0.3s ease'
                hint.style.opacity = '0'
                setTimeout(() => {
                    canvas.remove()
                    hint.remove()
                }, 500)
            }
        }

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true
            const rect = canvas.getBoundingClientRect()
            lastX = e.clientX - rect.left
            lastY = e.clientY - rect.top
            scratch(lastX, lastY)
            hint.style.opacity = '0'
        })

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return
            const rect = canvas.getBoundingClientRect()
            const x = e.clientX - rect.left
            const y = e.clientY - rect.top

            // ç»˜åˆ¶è¿ç»­çš„çº¿
            const scale = canvas.width / canvas.offsetWidth
            ctx.beginPath()
            ctx.lineWidth = 60
            ctx.lineCap = 'round'
            ctx.lineJoin = 'round'
            ctx.moveTo(lastX * scale, lastY * scale)
            ctx.lineTo(x * scale, y * scale)
            ctx.stroke()

            lastX = x
            lastY = y

            // æ£€æŸ¥åˆ®å¼€ç™¾åˆ†æ¯”
            if (calculateScratchPercentage() > 50) {
                canvas.style.transition = 'opacity 0.5s ease'
                canvas.style.opacity = '0'
                hint.style.transition = 'opacity 0.3s ease'
                hint.style.opacity = '0'
                setTimeout(() => {
                    canvas.remove()
                    hint.remove()
                }, 500)
            }
        })

        canvas.addEventListener('mouseup', () => {
            isDrawing = false
        })

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false
        })

        // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault()
            isDrawing = true
            const rect = canvas.getBoundingClientRect()
            const touch = e.touches[0]
            lastX = touch.clientX - rect.left
            lastY = touch.clientY - rect.top
            scratch(lastX, lastY)
            hint.style.opacity = '0'
        })

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault()
            if (!isDrawing) return
            const rect = canvas.getBoundingClientRect()
            const touch = e.touches[0]
            const x = touch.clientX - rect.left
            const y = touch.clientY - rect.top

            const scale = canvas.width / canvas.offsetWidth
            ctx.beginPath()
            ctx.lineWidth = 60
            ctx.lineCap = 'round'
            ctx.lineJoin = 'round'
            ctx.moveTo(lastX * scale, lastY * scale)
            ctx.lineTo(x * scale, y * scale)
            ctx.stroke()

            lastX = x
            lastY = y

            if (calculateScratchPercentage() > 50) {
                canvas.style.transition = 'opacity 0.5s ease'
                canvas.style.opacity = '0'
                hint.style.transition = 'opacity 0.3s ease'
                hint.style.opacity = '0'
                setTimeout(() => {
                    canvas.remove()
                    hint.remove()
                }, 500)
            }
        })

        canvas.addEventListener('touchend', () => {
            isDrawing = false
        })
    }

    hideProcessing()
}

// åŠé€æ˜åˆ®åˆ®ä¹æ•ˆæœå®ç°
function createTransparentScratchEffect(imageBlob) {
    // æ¸…ç©ºå›¾ç‰‡å®¹å™¨
    imgContainer.innerHTML = ''

    // åˆ›å»ºåˆ®åˆ®ä¹å®¹å™¨
    const scratchContainer = document.createElement('div')
    scratchContainer.className = 'scratch-container'

    // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
    const scratchImg = document.createElement('img')
    scratchImg.className = 'scratch-image'
    scratchImg.src = URL.createObjectURL(imageBlob)

    // åˆ›å»ºç”»å¸ƒï¼ˆé®ç½©å±‚ï¼‰
    const canvas = document.createElement('canvas')
    canvas.className = 'scratch-canvas'

    // åˆ›å»ºæç¤ºæ–‡å­—
    const hint = document.createElement('div')
    hint.className = 'scratch-hint'
    hint.textContent = 'ğŸ‘† æ»‘åŠ¨é¼ æ ‡åˆ®å¼€æŸ¥çœ‹å›¾ç‰‡'

    // ç»„è£…å…ƒç´ 
    scratchContainer.appendChild(scratchImg)
    scratchContainer.appendChild(canvas)
    scratchContainer.appendChild(hint)
    imgContainer.appendChild(scratchContainer)
    imgContainer.classList.add('has-image')

    // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆååˆå§‹åŒ–ç”»å¸ƒ
    scratchImg.onload = () => {
        const rect = scratchImg.getBoundingClientRect()
        canvas.width = scratchImg.naturalWidth
        canvas.height = scratchImg.naturalHeight
        canvas.style.width = scratchImg.offsetWidth + 'px'
        canvas.style.height = scratchImg.offsetHeight + 'px'

        const ctx = canvas.getContext('2d')

        // ç»˜åˆ¶åŠé€æ˜é®ç½©å±‚ - ç£¨ç ‚ç»ç’ƒæ•ˆæœ
        const gradient = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0,
            canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
        )
        gradient.addColorStop(0, 'rgba(200, 200, 200, 0.95)')
        gradient.addColorStop(0.5, 'rgba(180, 180, 180, 0.90)')
        gradient.addColorStop(1, 'rgba(160, 160, 160, 0.85)')
        ctx.fillStyle = gradient
        ctx.fillRect(0, 0, canvas.width, canvas.height)

        // æ·»åŠ ç£¨ç ‚æ•ˆæœ
        for (let i = 0; i < canvas.height; i += 3) {
            const alpha = 0.1 + Math.random() * 0.1
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`
            ctx.fillRect(0, i, canvas.width, 2)
        }

        // æ·»åŠ æ–‡å­—æç¤º
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'
        ctx.font = `bold ${canvas.width / 15}px Arial`
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.fillText('åˆ®å¼€æŸ¥çœ‹', canvas.width / 2, canvas.height / 2)

        ctx.globalCompositeOperation = 'destination-out'

        let isDrawing = false
        let lastX = 0
        let lastY = 0
        let scratchedPixels = 0
        const totalPixels = canvas.width * canvas.height

        // è®¡ç®—é€æ˜åº¦ç™¾åˆ†æ¯”
        function calculateTransparency() {
            return (scratchedPixels / totalPixels) * 100
        }

        // æ›´æ–°é®ç½©é€æ˜åº¦
        function updateCanvasOpacity() {
            const transparency = calculateTransparency()
            // æ ¹æ®åˆ®å¼€çš„ç™¾åˆ†æ¯”åŠ¨æ€è°ƒæ•´æ•´ä¸ªç”»å¸ƒçš„é€æ˜åº¦
            // 0% åˆ®å¼€ -> opacity 1.0
            // 50% åˆ®å¼€ -> opacity 0.5
            // 100% åˆ®å¼€ -> opacity 0
            const opacity = Math.max(0, 1 - (transparency / 50))
            canvas.style.opacity = opacity.toString()

            // å¦‚æœé€æ˜åº¦è¶…è¿‡50%ï¼Œè‡ªåŠ¨å®Œå…¨ç§»é™¤é®ç½©
            if (transparency > 50) {
                canvas.style.transition = 'opacity 0.5s ease'
                canvas.style.opacity = '0'
                hint.style.transition = 'opacity 0.3s ease'
                hint.style.opacity = '0'
                setTimeout(() => {
                    canvas.remove()
                    hint.remove()
                }, 500)
            }
        }

        // ç»˜åˆ¶åˆ®ç—•å¹¶è®¡ç®—åˆ®å¼€çš„åƒç´ 
        function scratch(x, y) {
            const scale = canvas.width / canvas.offsetWidth
            const scaledX = x * scale
            const scaledY = y * scale
            const radius = 30

            ctx.beginPath()
            ctx.arc(scaledX, scaledY, radius, 0, Math.PI * 2)
            ctx.fill()

            // ä¼°ç®—åˆ®å¼€çš„åƒç´ æ•°ï¼ˆåœ†å½¢é¢ç§¯ï¼‰
            scratchedPixels += Math.PI * radius * radius
            updateCanvasOpacity()
        }

        // ç»˜åˆ¶åˆ®ç—•çº¿æ®µ
        function scratchLine(x1, y1, x2, y2) {
            const scale = canvas.width / canvas.offsetWidth
            const lineWidth = 60

            ctx.beginPath()
            ctx.lineWidth = lineWidth
            ctx.lineCap = 'round'
            ctx.lineJoin = 'round'
            ctx.moveTo(x1 * scale, y1 * scale)
            ctx.lineTo(x2 * scale, y2 * scale)
            ctx.stroke()

            // ä¼°ç®—çº¿æ®µåˆ®å¼€çš„åƒç´ æ•°
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) * scale
            scratchedPixels += distance * lineWidth
            updateCanvasOpacity()
        }

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true
            const rect = canvas.getBoundingClientRect()
            lastX = e.clientX - rect.left
            lastY = e.clientY - rect.top
            scratch(lastX, lastY)
            hint.style.opacity = '0'
        })

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return
            const rect = canvas.getBoundingClientRect()
            const x = e.clientX - rect.left
            const y = e.clientY - rect.top

            scratchLine(lastX, lastY, x, y)

            lastX = x
            lastY = y
        })

        canvas.addEventListener('mouseup', () => {
            isDrawing = false
        })

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false
        })

        // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault()
            isDrawing = true
            const rect = canvas.getBoundingClientRect()
            const touch = e.touches[0]
            lastX = touch.clientX - rect.left
            lastY = touch.clientY - rect.top
            scratch(lastX, lastY)
            hint.style.opacity = '0'
        })

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault()
            if (!isDrawing) return
            const rect = canvas.getBoundingClientRect()
            const touch = e.touches[0]
            const x = touch.clientX - rect.left
            const y = touch.clientY - rect.top

            scratchLine(lastX, lastY, x, y)

            lastX = x
            lastY = y
        })

        canvas.addEventListener('touchend', () => {
            isDrawing = false
        })
    }

    hideProcessing()
}

async function setsrc(src, skipAuto = false, preserveExif = true, sourceBlob = null){
    // é‡ç½®å…ƒæ•°æ®å˜é‡ï¼Œé˜²æ­¢ä½¿ç”¨æ—§å›¾ç‰‡çš„å…ƒæ•°æ®
    originalExifData = null
    originalPngMetadata = null
    originalImageFormat = 'jpeg'
    
    // å…ˆæ£€æŸ¥å¹¶é‡å»ºDOMï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (!document.getElementById('display-img')) {
        imgContainer.innerHTML = `
            <img id="display-img" style="display: none;" />
            <div class="empty-state" id="empty-state">
                æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ / ç‚¹å‡»é€‰æ‹© / æŒ‰ Ctrl+V ç²˜è´´<br>
                <small style="opacity: 0.7;">æ”¯æŒæ‹–æ”¾ã€å‰ªåˆ‡æ¿ç²˜è´´ã€æ–‡ä»¶é€‰æ‹©</small>
            </div>
            <div class="processing-state" id="processing-state">æ­£åœ¨å¤„ç†å›¾ç‰‡</div>
        `
        // æ›´æ–°å…¨å±€å˜é‡
        img = document.getElementById("display-img")
        emptyState = document.getElementById("empty-state")
        processingState = document.getElementById("processing-state")
    }

    // æ¸…é™¤æ—§çš„èµ„æº
    if (img && img.src && img.src.startsWith('blob:')) {
        URL.revokeObjectURL(img.src)
    }

    // æ¸…é™¤ä¹‹å‰çš„ onload äº‹ä»¶ï¼Œé˜²æ­¢é‡å¤è§¦å‘
    if (img) img.onload = null

    console.log('setsrc è¢«è°ƒç”¨:', {src: src.substring(0, 50), skipAuto, preserveExif, hasBlob: !!sourceBlob})

    // æå–å…ƒæ•°æ®ï¼ˆåªåœ¨é¦–æ¬¡åŠ è½½æ—¶ï¼‰
    if (preserveExif && !skipAuto && sourceBlob) {
        console.log('å¼€å§‹æå–å…ƒæ•°æ®...')
        // å…ˆæå– PNG å…ƒæ•°æ®
        originalPngMetadata = await extractPngMetadata(sourceBlob)

        // è®¾ç½® onload äº‹ä»¶ï¼ˆå¿…é¡»åœ¨è®¾ç½® src ä¹‹å‰ï¼‰
        img.onload = async () => {
            console.log('å›¾ç‰‡åŠ è½½å®Œæˆ, å¼€å§‹æå–EXIF...')
            console.log('img å…ƒç´ ä¿¡æ¯:', {
                width: img.width,
                height: img.height,
                display: img.style.display,
                src: img.src.substring(0, 50)
            })
            // æå– EXIF æ•°æ®
            originalExifData = await extractExifData(img)

            // ç«‹å³æ¸…é™¤ onloadï¼Œé˜²æ­¢åç»­é‡å¤è§¦å‘
            img.onload = null

            // æ ¹æ®è®¾ç½®è‡ªåŠ¨å¤„ç†å›¾ç‰‡
            const autoAction = getAutoAction()
            console.log('è‡ªåŠ¨å¤„ç†é€‰é¡¹:', autoAction)
            if (autoAction === 'encrypt') {
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        encrypt(img)
                    })
                })
            } else if (autoAction === 'decrypt') {
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        decrypt(img)
                    })
                })
            } else {
                console.log('ä¸è¿›è¡Œè‡ªåŠ¨å¤„ç†,ç¡®ä¿å›¾ç‰‡å¯è§')
                // ç¡®ä¿æ‰€æœ‰å…ƒç´ çŠ¶æ€æ­£ç¡®
                const currentImg = document.getElementById("display-img")
                const currentEmpty = document.getElementById("empty-state")
                const currentProcessing = document.getElementById("processing-state")

                if(currentImg) {
                    currentImg.style.display = "block"
                    console.log('å·²è®¾ç½® img display ä¸º block')
                }
                if(currentEmpty) {
                    currentEmpty.style.display = "none"
                    console.log('å·²éšè— empty state')
                }
                if(currentProcessing) {
                    currentProcessing.style.display = "none"
                    console.log('å·²éšè— processing state')
                }
                imgContainer.classList.add('has-image')
                console.log('å·²æ·»åŠ  has-image class')
            }
        }

        // è®¾ç½® onerror äº‹ä»¶ç”¨äºè°ƒè¯•
        img.onerror = (e) => {
            console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', e)
        }

        // è®¾ç½® src è§¦å‘åŠ è½½ï¼ˆå¿…é¡»åœ¨ onload ä¹‹åï¼‰
        img.src = src
        img.style.display = "block"
        emptyState.style.display = "none"
        processingState.style.display = "none"
    } else if (!skipAuto) {
        console.log('ä¸æå–å…ƒæ•°æ®,æ£€æŸ¥è‡ªåŠ¨å¤„ç†...')
        // æ ¹æ®è®¾ç½®è‡ªåŠ¨å¤„ç†å›¾ç‰‡ï¼ˆä¸æå–å…ƒæ•°æ®ï¼‰
        const autoAction = getAutoAction()
        console.log('è‡ªåŠ¨å¤„ç†é€‰é¡¹:', autoAction)
        if (autoAction === 'encrypt') {
            img.onload = () => {
                img.onload = null
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        encrypt(img)
                    })
                })
            }
        } else if (autoAction === 'decrypt') {
            img.onload = () => {
                img.onload = null
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        decrypt(img)
                    })
                })
            }
        }

        // è®¾ç½® src è§¦å‘åŠ è½½
        img.src = src
        img.style.display = "block"
        emptyState.style.display = "none"
        processingState.style.display = "none"
    } else {
        // skipAuto = trueï¼Œç›´æ¥æ˜¾ç¤º
        console.log('skipAuto=true, ç›´æ¥æ˜¾ç¤ºå›¾ç‰‡')
        img.src = src
        img.style.display = "block"
        emptyState.style.display = "none"
        processingState.style.display = "none"
    }
}
async function encrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height)
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(old_p, old_p + 4), new_p)
    }
    ctx.putImageData(imgdata2, 0, 0)

    // æ ¹æ®åŸå§‹æ ¼å¼è¾“å‡º
    if (originalImageFormat === 'png') {
        // è¾“å‡º PNG å¹¶æ³¨å…¥å…ƒæ•°æ®
        cvs.toBlob(async (blob) => {
            // æ³¨å…¥ PNG å…ƒæ•°æ®
            const blobWithMetadata = await injectPngMetadata(blob, originalPngMetadata)
            setsrc(URL.createObjectURL(blobWithMetadata), true, false) // skipAuto = true, preserveExif = false
        }, 'image/png')
    } else {
        // è¾“å‡º JPEG å¹¶æ³¨å…¥ EXIF
        const dataUrl = cvs.toDataURL('image/jpeg', 0.95)
        const dataUrlWithExif = injectExifToDataUrl(dataUrl, originalExifData)
        fetch(dataUrlWithExif)
            .then(res => res.blob())
            .then(blob => {
                setsrc(URL.createObjectURL(blob), true, false)
            })
    }
}
async function decrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height)
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(new_p, new_p + 4), old_p)
    }
    ctx.putImageData(imgdata2, 0, 0)

    // è·å–æ˜¾ç¤ºæ¨¡å¼
    const displayMode = getDisplayMode()

    // æ ¹æ®åŸå§‹æ ¼å¼è¾“å‡º
    if (originalImageFormat === 'png') {
        // è¾“å‡º PNG å¹¶æ³¨å…¥å…ƒæ•°æ®
        cvs.toBlob(async (blob) => {
            // æ³¨å…¥ PNG å…ƒæ•°æ®
            const blobWithMetadata = await injectPngMetadata(blob, originalPngMetadata)

            // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©æ˜¾ç¤ºæ–¹å¼
            if (displayMode === 'scratch') {
                createScratchEffect(blobWithMetadata)
            } else if (displayMode === 'scratch-transparent') {
                createTransparentScratchEffect(blobWithMetadata)
            } else {
                setsrc(URL.createObjectURL(blobWithMetadata), true, false) // skipAuto = true, preserveExif = false
            }
        }, 'image/png')
    } else {
        // è¾“å‡º JPEG å¹¶æ³¨å…¥ EXIF
        const dataUrl = cvs.toDataURL('image/jpeg', 0.95)
        const dataUrlWithExif = injectExifToDataUrl(dataUrl, originalExifData)
        fetch(dataUrlWithExif)
            .then(res => res.blob())
            .then(blob => {
                // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©æ˜¾ç¤ºæ–¹å¼
                if (displayMode === 'scratch') {
                    createScratchEffect(blob)
                } else if (displayMode === 'scratch-transparent') {
                    createTransparentScratchEffect(blob)
                } else {
                    setsrc(URL.createObjectURL(blob), true, false)
                }
            })
    }
}
const ipt = document.getElementById("ipt")
ipt.onchange = () => {
    if(ipt.files.length > 0){
        const file = ipt.files[0]
        setsrc(URL.createObjectURL(file), false, true, file)
    }
}
const btn_enc = document.getElementById("enc")
btn_enc.onclick = () => {
    const currentImg = document.getElementById("display-img")
    if(currentImg && currentImg.src){
        showProcessing()
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                encrypt(currentImg)
            })
        })
    }
}
const btn_dec = document.getElementById("dec")
btn_dec.onclick = () => {
    const currentImg = document.getElementById("display-img")
    if(currentImg && currentImg.src){
        showProcessing()
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                decrypt(currentImg)
            })
        })
    }
}
const btn_restore = document.getElementById("re")
btn_restore.onclick = () => {
    if(ipt.files.length > 0){
        const file = ipt.files[0]
        setsrc(URL.createObjectURL(file), false, true, file)
    }
}

// AI ç”»å›¾ç«™æŒ‰é’®
const btn_ai_site = document.getElementById("ai-site")
btn_ai_site.onclick = () => {
    window.open('https://sd.exacg.cc/', '_blank')
}

// å‰ªåˆ‡æ¿ç²˜è´´åŠŸèƒ½
async function pasteFromClipboard() {
    try {
        const clipboardItems = await navigator.clipboard.read()
        for (const item of clipboardItems) {
            for (const type of item.types) {
                if (type.startsWith('image/')) {
                    const blob = await item.getType(type)
                    setsrc(URL.createObjectURL(blob), false, true, blob)
                    return true
                }
            }
        }
        alert('å‰ªåˆ‡æ¿ä¸­æ²¡æœ‰å›¾ç‰‡')
        return false
    } catch (err) {
        console.error('è¯»å–å‰ªåˆ‡æ¿å¤±è´¥:', err)
        alert('æ— æ³•è¯»å–å‰ªåˆ‡æ¿ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™')
        return false
    }
}

// ç²˜è´´æŒ‰é’®ç‚¹å‡»äº‹ä»¶
const btn_paste = document.getElementById("paste")
btn_paste.onclick = () => {
    pasteFromClipboard()
}

// å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬ Ctrl+V
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        // å¦‚æœç„¦ç‚¹ä¸åœ¨è¾“å…¥æ¡†ä¸­ï¼Œæ‰æ‹¦æˆªç²˜è´´äº‹ä»¶
        if (document.activeElement.tagName !== 'INPUT' &&
            document.activeElement.tagName !== 'TEXTAREA') {
            e.preventDefault()
            pasteFromClipboard()
        }
    }
})

// é¡µé¢ç²˜è´´äº‹ä»¶ç›‘å¬
document.addEventListener('paste', (e) => {
    const items = e.clipboardData?.items
    if (!items) return

    for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
            e.preventDefault()
            const blob = items[i].getAsFile()
            if (blob) {
                setsrc(URL.createObjectURL(blob), false, true, blob)
            }
            break
        }
    }
})

// æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
const dragCounter = { value: 0 }

// é˜²æ­¢é»˜è®¤æ‹–æ‹½è¡Œä¸º
document.addEventListener('dragover', (e) => {
    e.preventDefault()
})

document.addEventListener('drop', (e) => {
    e.preventDefault()
})

// å›¾ç‰‡å®¹å™¨æ‹–æ‹½äº‹ä»¶
imgContainer.addEventListener('dragenter', (e) => {
    e.preventDefault()
    dragCounter.value++
    imgContainer.classList.add('drag-over')
})

imgContainer.addEventListener('dragover', (e) => {
    e.preventDefault()
})

imgContainer.addEventListener('dragleave', (e) => {
    e.preventDefault()
    dragCounter.value--
    if (dragCounter.value === 0) {
        imgContainer.classList.remove('drag-over')
    }
})

imgContainer.addEventListener('drop', (e) => {
    e.preventDefault()
    dragCounter.value = 0
    imgContainer.classList.remove('drag-over')

    const files = e.dataTransfer?.files
    if (!files || files.length === 0) return

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶
    for (let i = 0; i < files.length; i++) {
        if (files[i].type.startsWith('image/')) {
            const file = files[i]
            setsrc(URL.createObjectURL(file), false, true, file)
            break
        }
    }
})

// æ•´ä¸ªé¡µé¢çš„æ‹–æ‹½äº‹ä»¶ï¼ˆå…¨å±€ï¼‰
let globalDragCounter = 0

document.addEventListener('dragenter', (e) => {
    e.preventDefault()
    globalDragCounter++
    if (e.dataTransfer?.types.includes('Files')) {
        imgContainer.style.outline = '3px solid #667eea'
    }
})

document.addEventListener('dragleave', (e) => {
    e.preventDefault()
    globalDragCounter--
    if (globalDragCounter === 0) {
        imgContainer.style.outline = 'none'
    }
})

document.addEventListener('drop', (e) => {
    globalDragCounter = 0
    imgContainer.style.outline = 'none'
})
</script>
</body>
</html>
