<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ¢¦ç¾½çš„å°ç•ªèŒ„å›¾ç‰‡æ··æ·†</title>
<!-- EXIF å¤„ç†åº“ -->
<script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Microsoft YaHei', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: #333;
}

.container {
    width: 100%;
    max-width: 900px;
    text-align: center;
}

.card {
    background: rgba(255, 255, 255, 0.98);
    border-radius: 24px;
    padding: 40px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
}

h1 {
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 20px;
    letter-spacing: 1px;
}

.description {
    max-width: 600px;
    margin: 0 auto 40px;
    color: #666;
    font-size: 1rem;
    line-height: 1.8;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 12px;
    border-left: 4px solid #667eea;
}

.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 40px;
}

.normal_button {
    min-width: 120px;
    height: 48px;
    line-height: 48px;
    font-size: 1rem;
    padding: 0 24px;
    border: none;
    border-radius: 12px;
    display: inline-block;
    position: relative;
    vertical-align: middle;
    color: #fff;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    overflow: hidden;
}

.normal_button::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.normal_button:hover::before {
    transform: translateX(100%);
}

.normal_button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.normal_button:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.btn-select {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.btn-paste {
    background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
}

.btn-encrypt {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

.btn-decrypt {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

.btn-restore {
    background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
}

.btn-ai-site {
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
    color: #333 !important;
}

.ipt_btn {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.image-container {
    background: #f8f9fa;
    border-radius: 16px;
    padding: 20px;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px dashed #dee2e6;
    transition: all 0.3s ease;
}

.image-container.has-image {
    border-color: #667eea;
    background: #fff;
}

.image-container.drag-over {
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.1);
    transform: scale(1.02);
}

#display-img {
    max-width: 100%;
    max-height: 60vh;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
}

#display-img:hover {
    transform: scale(1.02);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}

.empty-state {
    color: #adb5bd;
    font-size: 1.1rem;
}

.processing-state {
    color: #667eea;
    font-size: 1.1rem;
    font-weight: 600;
    display: none;
}

.processing-state::after {
    content: '...';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
}

.settings-panel {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    border: 1px solid #dee2e6;
}

.settings-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: #495057;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.radio-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    padding: 8px 16px;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: #fff;
    border: 2px solid transparent;
}

.radio-option:hover {
    background: #f8f9fa;
    border-color: #667eea;
}

.radio-option input[type="radio"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #667eea;
}

.radio-option label {
    cursor: pointer;
    font-size: 0.95rem;
    color: #495057;
    user-select: none;
}

.radio-option input[type="radio"]:checked + label {
    color: #667eea;
    font-weight: 600;
}

@media (max-width: 768px) {
    .card {
        padding: 24px;
    }

    h1 {
        font-size: 2rem;
    }

    .description {
        font-size: 0.9rem;
        padding: 15px;
    }

    .button-group {
        gap: 10px;
    }

    .normal_button {
        min-width: 100px;
        height: 44px;
        line-height: 44px;
        font-size: 0.9rem;
        padding: 0 16px;
    }
}

/* åŠ è½½åŠ¨ç”» */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.card {
    animation: fadeIn 0.6s ease;
}
</style>
</head>
<body>
<div class="container">
    <div class="card">
        <h1>ğŸ… æ¢¦ç¾½çš„å°ç•ªèŒ„å›¾ç‰‡æ··æ·†v2.0</h1>

        <div class="settings-panel">
            <div class="settings-title">âš™ï¸ è‡ªåŠ¨å¤„ç†è®¾ç½®</div>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="auto-none" name="auto-action" value="none" checked>
                    <label for="auto-none">ä¸å¤„ç†</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="auto-encrypt" name="auto-action" value="encrypt">
                    <label for="auto-encrypt">ğŸ”’ è‡ªåŠ¨æ··æ·†</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="auto-decrypt" name="auto-action" value="decrypt">
                    <label for="auto-decrypt">ğŸ”“ è‡ªåŠ¨è§£æ··æ·†</label>
                </div>
            </div>
        </div>

        <div class="button-group">
            <span class="normal_button btn-select">
                ğŸ“ é€‰æ‹©å›¾ç‰‡
                <input type="file" accept="image/*" id="ipt" class="ipt_btn" />
            </span>
            <button id="paste" class="normal_button btn-paste">ğŸ“‹ ç²˜è´´å›¾ç‰‡</button>
            <button id="enc" class="normal_button btn-encrypt">ğŸ”’ æ··æ·†</button>
            <button id="dec" class="normal_button btn-decrypt">ğŸ”“ è§£æ··æ·†</button>
            <button id="re" class="normal_button btn-restore">â†» è¿˜åŸ</button>
            <button id="ai-site" class="normal_button btn-ai-site">ğŸ¨ æ‰“å¼€æ¢¦ç¾½çš„AIç”»å›¾ç«™</button>
        </div>

        <div class="image-container" id="img-container">
            <img id="display-img" style="display: none;" />
            <div class="empty-state" id="empty-state">
                æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ / ç‚¹å‡»é€‰æ‹© / æŒ‰ Ctrl+V ç²˜è´´<br>
                <small style="opacity: 0.7;">æ”¯æŒæ‹–æ”¾ã€å‰ªåˆ‡æ¿ç²˜è´´ã€æ–‡ä»¶é€‰æ‹©</small>
            </div>
            <div class="processing-state" id="processing-state">æ­£åœ¨å¤„ç†å›¾ç‰‡</div>
        </div>
    </div>
</div>
<script>
function gilbert2d(width, height) {
    /**
     * Generalized Hilbert ('gilbert') space-filling curve for arbitrary-sized
     * 2D rectangular grids. Generates discrete 2D coordinates to fill a rectangle
     * of size (width x height).
     */
    const coordinates = [];

    if (width >= height) {
        generate2d(0, 0, width, 0, 0, height, coordinates);
    } else {
        generate2d(0, 0, 0, height, width, 0, coordinates);
    }

    return coordinates;
}

function generate2d(x, y, ax, ay, bx, by, coordinates) {
    const w = Math.abs(ax + ay);
    const h = Math.abs(bx + by);

    const dax = Math.sign(ax), day = Math.sign(ay); // unit major direction
    const dbx = Math.sign(bx), dby = Math.sign(by); // unit orthogonal direction

    if (h === 1) {
        // trivial row fill
        for (let i = 0; i < w; i++) {
            coordinates.push([x, y]);
            x += dax;
            y += day;
        }
        return;
    }

    if (w === 1) {
        // trivial column fill
        for (let i = 0; i < h; i++) {
            coordinates.push([x, y]);
            x += dbx;
            y += dby;
        }
        return;
    }

    let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
    let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);

    const w2 = Math.abs(ax2 + ay2);
    const h2 = Math.abs(bx2 + by2);

    if (2 * w > 3 * h) {
        if ((w2 % 2) && (w > 2)) {
            // prefer even steps
            ax2 += dax;
            ay2 += day;
        }

        // long case: split in two parts only
        generate2d(x, y, ax2, ay2, bx, by, coordinates);
        generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);

    } else {
        if ((h2 % 2) && (h > 2)) {
            // prefer even steps
            bx2 += dbx;
            by2 += dby;
        }

        // standard case: one step up, one long horizontal, one step down
        generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
        generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
        generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
            -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
    }
}
</script>
<script>
const img = document.getElementById("display-img")
const imgContainer = document.getElementById("img-container")
const emptyState = document.getElementById("empty-state")
const processingState = document.getElementById("processing-state")

// å­˜å‚¨åŸå§‹å›¾ç‰‡çš„ EXIF æ•°æ®å’Œ PNG å…ƒæ•°æ®
let originalExifData = null
let originalPngMetadata = null
let originalImageFormat = 'jpeg' // è®°å½•åŸå§‹å›¾ç‰‡æ ¼å¼

// ä» Blob/File ä¸­æå– PNG å…ƒæ•°æ®ï¼ˆtEXt chunksï¼‰
async function extractPngMetadata(blob) {
    try {
        const arrayBuffer = await blob.arrayBuffer()
        const bytes = new Uint8Array(arrayBuffer)

        // æ£€æŸ¥ PNG æ–‡ä»¶ç­¾å
        if (bytes[0] !== 0x89 || bytes[1] !== 0x50 || bytes[2] !== 0x4E || bytes[3] !== 0x47) {
            console.log('ä¸æ˜¯ PNG æ ¼å¼ï¼Œè·³è¿‡ PNG å…ƒæ•°æ®æå–')
            originalImageFormat = 'jpeg'
            return null
        }

        originalImageFormat = 'png'
        const metadata = {}
        let offset = 8 // è·³è¿‡ PNG ç­¾å

        while (offset < bytes.length) {
            // è¯»å–å—é•¿åº¦
            const length = (bytes[offset] << 24) | (bytes[offset + 1] << 16) |
                          (bytes[offset + 2] << 8) | bytes[offset + 3]
            offset += 4

            // è¯»å–å—ç±»å‹
            const type = String.fromCharCode(bytes[offset], bytes[offset + 1],
                                            bytes[offset + 2], bytes[offset + 3])
            offset += 4

            // å¦‚æœæ˜¯ tEXt æˆ– iTXt å—ï¼Œæå–æ•°æ®
            if (type === 'tEXt' || type === 'iTXt') {
                const chunkData = bytes.slice(offset, offset + length)
                let keyword = ''
                let text = ''
                let i = 0

                // è¯»å–å…³é”®å­—ï¼ˆä»¥ null ç»“å°¾ï¼‰
                while (i < chunkData.length && chunkData[i] !== 0) {
                    keyword += String.fromCharCode(chunkData[i])
                    i++
                }
                i++ // è·³è¿‡ null åˆ†éš”ç¬¦

                // è¯»å–æ–‡æœ¬å†…å®¹
                if (type === 'tEXt') {
                    // tEXt: ç›´æ¥è¯»å– Latin-1 æ–‡æœ¬
                    const decoder = new TextDecoder('latin1')
                    text = decoder.decode(chunkData.slice(i))
                } else if (type === 'iTXt') {
                    // iTXt: è·³è¿‡å‹ç¼©æ ‡å¿—ã€å‹ç¼©æ–¹æ³•ã€è¯­è¨€æ ‡ç­¾ã€ç¿»è¯‘å…³é”®å­—
                    i++ // å‹ç¼©æ ‡å¿—
                    i++ // å‹ç¼©æ–¹æ³•
                    while (i < chunkData.length && chunkData[i] !== 0) i++ // è¯­è¨€æ ‡ç­¾
                    i++
                    while (i < chunkData.length && chunkData[i] !== 0) i++ // ç¿»è¯‘å…³é”®å­—
                    i++
                    const decoder = new TextDecoder('utf-8')
                    text = decoder.decode(chunkData.slice(i))
                }

                metadata[keyword] = text
            }

            offset += length + 4 // è·³è¿‡æ•°æ®å’Œ CRC

            // å¦‚æœé‡åˆ° IEND å—ï¼Œåœæ­¢
            if (type === 'IEND') break
        }

        if (Object.keys(metadata).length > 0) {
            console.log('æå–åˆ° PNG å…ƒæ•°æ®:', metadata)
            return metadata
        }

        console.log('PNG æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ° tEXt å…ƒæ•°æ®')
        return null
    } catch (err) {
        console.error('æå– PNG å…ƒæ•°æ®å¤±è´¥:', err)
        return null
    }
}

// æå–å›¾ç‰‡çš„ EXIF æ•°æ®
function extractExifData(imgElement) {
    return new Promise((resolve) => {
        if (typeof EXIF === 'undefined') {
            console.warn('EXIF åº“æœªåŠ è½½')
            resolve(null)
            return
        }

        EXIF.getData(imgElement, function() {
            try {
                const allMetaData = EXIF.getAllTags(this)
                if (Object.keys(allMetaData).length > 0) {
                    console.log('æå–åˆ° EXIF æ•°æ®:', allMetaData)
                    resolve(allMetaData)
                } else {
                    console.log('å›¾ç‰‡æ²¡æœ‰ EXIF æ•°æ®')
                    resolve(null)
                }
            } catch (err) {
                console.error('æå– EXIF å¤±è´¥:', err)
                resolve(null)
            }
        })
    })
}

// å°† PNG å…ƒæ•°æ®æ³¨å…¥åˆ° PNG æ•°æ®ä¸­
async function injectPngMetadata(pngBlob, metadata) {
    if (!metadata || Object.keys(metadata).length === 0) {
        return pngBlob
    }

    try {
        const arrayBuffer = await pngBlob.arrayBuffer()
        const bytes = new Uint8Array(arrayBuffer)

        // åˆ›å»º tEXt å—çš„å‡½æ•°
        function createTextChunk(keyword, text) {
            const encoder = new TextEncoder()
            const keywordBytes = encoder.encode(keyword)
            const textBytes = encoder.encode(text)
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length)

            chunkData.set(keywordBytes, 0)
            chunkData[keywordBytes.length] = 0 // null åˆ†éš”ç¬¦
            chunkData.set(textBytes, keywordBytes.length + 1)

            // åˆ›å»ºå®Œæ•´çš„å—ï¼šé•¿åº¦ + ç±»å‹ + æ•°æ® + CRC
            const chunk = new Uint8Array(4 + 4 + chunkData.length + 4)
            const view = new DataView(chunk.buffer)

            // é•¿åº¦
            view.setUint32(0, chunkData.length, false)

            // ç±»å‹ "tEXt"
            chunk[4] = 116 // 't'
            chunk[5] = 69  // 'E'
            chunk[6] = 88  // 'X'
            chunk[7] = 116 // 't'

            // æ•°æ®
            chunk.set(chunkData, 8)

            // CRC
            const crc = calculateCRC(chunk.slice(4, 8 + chunkData.length))
            view.setUint32(8 + chunkData.length, crc, false)

            return chunk
        }

        // CRC32 è®¡ç®—
        function calculateCRC(data) {
            let crc = 0xFFFFFFFF
            for (let i = 0; i < data.length; i++) {
                crc = crc ^ data[i]
                for (let j = 0; j < 8; j++) {
                    crc = (crc >>> 1) ^ ((crc & 1) ? 0xEDB88320 : 0)
                }
            }
            return (crc ^ 0xFFFFFFFF) >>> 0
        }

        // æ‰¾åˆ° IDAT å—çš„ä½ç½®ï¼ˆåœ¨å®ƒä¹‹å‰æ’å…¥ tEXt å—ï¼‰
        let idatOffset = 8
        while (idatOffset < bytes.length) {
            const type = String.fromCharCode(bytes[idatOffset + 4], bytes[idatOffset + 5],
                                            bytes[idatOffset + 6], bytes[idatOffset + 7])
            if (type === 'IDAT') break

            const length = (bytes[idatOffset] << 24) | (bytes[idatOffset + 1] << 16) |
                          (bytes[idatOffset + 2] << 8) | bytes[idatOffset + 3]
            idatOffset += 4 + 4 + length + 4
        }

        // æ„å»ºæ–°çš„ PNG
        const textChunks = []
        for (const [keyword, text] of Object.entries(metadata)) {
            textChunks.push(createTextChunk(keyword, text))
        }

        const totalTextLength = textChunks.reduce((sum, chunk) => sum + chunk.length, 0)
        const newBytes = new Uint8Array(bytes.length + totalTextLength)

        // å¤åˆ¶ PNG å¤´å’Œ IHDR ç­‰å—
        newBytes.set(bytes.slice(0, idatOffset), 0)

        // æ’å…¥ tEXt å—
        let offset = idatOffset
        for (const chunk of textChunks) {
            newBytes.set(chunk, offset)
            offset += chunk.length
        }

        // å¤åˆ¶å‰©ä½™éƒ¨åˆ†ï¼ˆIDAT å’Œåç»­å—ï¼‰
        newBytes.set(bytes.slice(idatOffset), offset)

        console.log('PNG å…ƒæ•°æ®å·²æ³¨å…¥')
        return new Blob([newBytes], { type: 'image/png' })
    } catch (err) {
        console.error('æ³¨å…¥ PNG å…ƒæ•°æ®å¤±è´¥:', err)
        return pngBlob
    }
}

// ä» Data URL ä¸­æå– EXIF æ•°æ®å¹¶æ³¨å…¥åˆ°æ–°å›¾ç‰‡
function injectExifToDataUrl(dataUrl, exifData) {
    if (!exifData || typeof piexif === 'undefined') {
        return dataUrl
    }

    try {
        // ä»åŸå§‹ EXIF æ•°æ®æ„å»º piexif æ ¼å¼çš„æ•°æ®
        const exifObj = {
            "0th": {},
            "Exif": {},
            "GPS": {},
            "Interop": {},
            "1st": {},
            "thumbnail": null
        }

        // ä¿ç•™å¸¸è§çš„ EXIF å­—æ®µ
        if (exifData.Make) exifObj["0th"][piexif.ImageIFD.Make] = exifData.Make
        if (exifData.Model) exifObj["0th"][piexif.ImageIFD.Model] = exifData.Model
        if (exifData.Software) exifObj["0th"][piexif.ImageIFD.Software] = exifData.Software
        if (exifData.DateTime) exifObj["0th"][piexif.ImageIFD.DateTime] = exifData.DateTime
        if (exifData.Artist) exifObj["0th"][piexif.ImageIFD.Artist] = exifData.Artist
        if (exifData.Copyright) exifObj["0th"][piexif.ImageIFD.Copyright] = exifData.Copyright

        // Exif å­—æ®µ
        if (exifData.DateTimeOriginal) exifObj["Exif"][piexif.ExifIFD.DateTimeOriginal] = exifData.DateTimeOriginal
        if (exifData.DateTimeDigitized) exifObj["Exif"][piexif.ExifIFD.DateTimeDigitized] = exifData.DateTimeDigitized
        if (exifData.ExposureTime) exifObj["Exif"][piexif.ExifIFD.ExposureTime] = exifData.ExposureTime
        if (exifData.FNumber) exifObj["Exif"][piexif.ExifIFD.FNumber] = exifData.FNumber
        if (exifData.ISO) exifObj["Exif"][piexif.ExifIFD.ISOSpeedRatings] = exifData.ISO
        if (exifData.FocalLength) exifObj["Exif"][piexif.ExifIFD.FocalLength] = exifData.FocalLength
        if (exifData.LensModel) exifObj["Exif"][piexif.ExifIFD.LensModel] = exifData.LensModel

        // GPS æ•°æ®
        if (exifData.GPSLatitude) exifObj["GPS"][piexif.GPSIFD.GPSLatitude] = exifData.GPSLatitude
        if (exifData.GPSLongitude) exifObj["GPS"][piexif.GPSIFD.GPSLongitude] = exifData.GPSLongitude

        const exifBytes = piexif.dump(exifObj)
        const newDataUrl = piexif.insert(exifBytes, dataUrl)
        console.log('EXIF æ•°æ®å·²æ³¨å…¥åˆ°æ–°å›¾ç‰‡')
        return newDataUrl
    } catch (err) {
        console.error('æ³¨å…¥ EXIF å¤±è´¥:', err)
        return dataUrl
    }
}

// æ˜¾ç¤ºå¤„ç†çŠ¶æ€
function showProcessing() {
    img.style.display = "none"
    emptyState.style.display = "none"
    processingState.style.display = "block"
    imgContainer.classList.add("has-image")
}

// éšè—å¤„ç†çŠ¶æ€
function hideProcessing() {
    processingState.style.display = "none"
}

// è·å–å½“å‰é€‰ä¸­çš„è‡ªåŠ¨å¤„ç†é€‰é¡¹
function getAutoAction() {
    const selected = document.querySelector('input[name="auto-action"]:checked')
    return selected ? selected.value : 'none'
}

async function setsrc(src, skipAuto = false, preserveExif = true, sourceBlob = null){
    URL.revokeObjectURL(img.src)

    // æ¸…é™¤ä¹‹å‰çš„ onload äº‹ä»¶ï¼Œé˜²æ­¢é‡å¤è§¦å‘
    img.onload = null

    img.src = src
    img.style.display = "block"
    emptyState.style.display = "none"
    processingState.style.display = "none"
    imgContainer.classList.add("has-image")

    // æå–å…ƒæ•°æ®ï¼ˆåªåœ¨é¦–æ¬¡åŠ è½½æ—¶ï¼‰
    if (preserveExif && !skipAuto && sourceBlob) {
        // å…ˆæå– PNG å…ƒæ•°æ®
        originalPngMetadata = await extractPngMetadata(sourceBlob)

        img.onload = async () => {
            // æå– EXIF æ•°æ®
            originalExifData = await extractExifData(img)

            // ç«‹å³æ¸…é™¤ onloadï¼Œé˜²æ­¢åç»­é‡å¤è§¦å‘
            img.onload = null

            // æ ¹æ®è®¾ç½®è‡ªåŠ¨å¤„ç†å›¾ç‰‡
            const autoAction = getAutoAction()
            if (autoAction === 'encrypt') {
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        encrypt(img)
                    })
                })
            } else if (autoAction === 'decrypt') {
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        decrypt(img)
                    })
                })
            }
        }
    } else if (!skipAuto) {
        // æ ¹æ®è®¾ç½®è‡ªåŠ¨å¤„ç†å›¾ç‰‡ï¼ˆä¸æå–å…ƒæ•°æ®ï¼‰
        const autoAction = getAutoAction()
        if (autoAction === 'encrypt') {
            img.onload = () => {
                img.onload = null
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        encrypt(img)
                    })
                })
            }
        } else if (autoAction === 'decrypt') {
            img.onload = () => {
                img.onload = null
                showProcessing()
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        decrypt(img)
                    })
                })
            }
        }
    }
}
async function encrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height)
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(old_p, old_p + 4), new_p)
    }
    ctx.putImageData(imgdata2, 0, 0)

    // æ ¹æ®åŸå§‹æ ¼å¼è¾“å‡º
    if (originalImageFormat === 'png') {
        // è¾“å‡º PNG å¹¶æ³¨å…¥å…ƒæ•°æ®
        cvs.toBlob(async (blob) => {
            // æ³¨å…¥ PNG å…ƒæ•°æ®
            const blobWithMetadata = await injectPngMetadata(blob, originalPngMetadata)
            setsrc(URL.createObjectURL(blobWithMetadata), true, false) // skipAuto = true, preserveExif = false
        }, 'image/png')
    } else {
        // è¾“å‡º JPEG å¹¶æ³¨å…¥ EXIF
        const dataUrl = cvs.toDataURL('image/jpeg', 0.95)
        const dataUrlWithExif = injectExifToDataUrl(dataUrl, originalExifData)
        fetch(dataUrlWithExif)
            .then(res => res.blob())
            .then(blob => {
                setsrc(URL.createObjectURL(blob), true, false)
            })
    }
}
async function decrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height)
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(new_p, new_p + 4), old_p)
    }
    ctx.putImageData(imgdata2, 0, 0)

    // æ ¹æ®åŸå§‹æ ¼å¼è¾“å‡º
    if (originalImageFormat === 'png') {
        // è¾“å‡º PNG å¹¶æ³¨å…¥å…ƒæ•°æ®
        cvs.toBlob(async (blob) => {
            // æ³¨å…¥ PNG å…ƒæ•°æ®
            const blobWithMetadata = await injectPngMetadata(blob, originalPngMetadata)
            setsrc(URL.createObjectURL(blobWithMetadata), true, false) // skipAuto = true, preserveExif = false
        }, 'image/png')
    } else {
        // è¾“å‡º JPEG å¹¶æ³¨å…¥ EXIF
        const dataUrl = cvs.toDataURL('image/jpeg', 0.95)
        const dataUrlWithExif = injectExifToDataUrl(dataUrl, originalExifData)
        fetch(dataUrlWithExif)
            .then(res => res.blob())
            .then(blob => {
                setsrc(URL.createObjectURL(blob), true, false)
            })
    }
}
const ipt = document.getElementById("ipt")
ipt.onchange = () => {
    if(ipt.files.length > 0){
        const file = ipt.files[0]
        setsrc(URL.createObjectURL(file), false, true, file)
    }
}
const btn_enc = document.getElementById("enc")
btn_enc.onclick = () => {
    if(img.src){
        showProcessing()
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                encrypt(img)
            })
        })
    }
}
const btn_dec = document.getElementById("dec")
btn_dec.onclick = () => {
    if(img.src){
        showProcessing()
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                decrypt(img)
            })
        })
    }
}
const btn_restore = document.getElementById("re")
btn_restore.onclick = () => {
    if(ipt.files.length > 0){
        const file = ipt.files[0]
        setsrc(URL.createObjectURL(file), false, true, file)
    }
}

// AI ç”»å›¾ç«™æŒ‰é’®
const btn_ai_site = document.getElementById("ai-site")
btn_ai_site.onclick = () => {
    window.open('https://sd.exacg.cc/', '_blank')
}

// å‰ªåˆ‡æ¿ç²˜è´´åŠŸèƒ½
async function pasteFromClipboard() {
    try {
        const clipboardItems = await navigator.clipboard.read()
        for (const item of clipboardItems) {
            for (const type of item.types) {
                if (type.startsWith('image/')) {
                    const blob = await item.getType(type)
                    setsrc(URL.createObjectURL(blob), false, true, blob)
                    return true
                }
            }
        }
        alert('å‰ªåˆ‡æ¿ä¸­æ²¡æœ‰å›¾ç‰‡')
        return false
    } catch (err) {
        console.error('è¯»å–å‰ªåˆ‡æ¿å¤±è´¥:', err)
        alert('æ— æ³•è¯»å–å‰ªåˆ‡æ¿ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™')
        return false
    }
}

// ç²˜è´´æŒ‰é’®ç‚¹å‡»äº‹ä»¶
const btn_paste = document.getElementById("paste")
btn_paste.onclick = () => {
    pasteFromClipboard()
}

// å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬ Ctrl+V
document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        // å¦‚æœç„¦ç‚¹ä¸åœ¨è¾“å…¥æ¡†ä¸­ï¼Œæ‰æ‹¦æˆªç²˜è´´äº‹ä»¶
        if (document.activeElement.tagName !== 'INPUT' &&
            document.activeElement.tagName !== 'TEXTAREA') {
            e.preventDefault()
            pasteFromClipboard()
        }
    }
})

// é¡µé¢ç²˜è´´äº‹ä»¶ç›‘å¬
document.addEventListener('paste', (e) => {
    const items = e.clipboardData?.items
    if (!items) return

    for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
            e.preventDefault()
            const blob = items[i].getAsFile()
            if (blob) {
                setsrc(URL.createObjectURL(blob), false, true, blob)
            }
            break
        }
    }
})

// æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
const dragCounter = { value: 0 }

// é˜²æ­¢é»˜è®¤æ‹–æ‹½è¡Œä¸º
document.addEventListener('dragover', (e) => {
    e.preventDefault()
})

document.addEventListener('drop', (e) => {
    e.preventDefault()
})

// å›¾ç‰‡å®¹å™¨æ‹–æ‹½äº‹ä»¶
imgContainer.addEventListener('dragenter', (e) => {
    e.preventDefault()
    dragCounter.value++
    imgContainer.classList.add('drag-over')
})

imgContainer.addEventListener('dragover', (e) => {
    e.preventDefault()
})

imgContainer.addEventListener('dragleave', (e) => {
    e.preventDefault()
    dragCounter.value--
    if (dragCounter.value === 0) {
        imgContainer.classList.remove('drag-over')
    }
})

imgContainer.addEventListener('drop', (e) => {
    e.preventDefault()
    dragCounter.value = 0
    imgContainer.classList.remove('drag-over')

    const files = e.dataTransfer?.files
    if (!files || files.length === 0) return

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶
    for (let i = 0; i < files.length; i++) {
        if (files[i].type.startsWith('image/')) {
            const file = files[i]
            setsrc(URL.createObjectURL(file), false, true, file)
            break
        }
    }
})

// æ•´ä¸ªé¡µé¢çš„æ‹–æ‹½äº‹ä»¶ï¼ˆå…¨å±€ï¼‰
let globalDragCounter = 0

document.addEventListener('dragenter', (e) => {
    e.preventDefault()
    globalDragCounter++
    if (e.dataTransfer?.types.includes('Files')) {
        imgContainer.style.outline = '3px solid #667eea'
    }
})

document.addEventListener('dragleave', (e) => {
    e.preventDefault()
    globalDragCounter--
    if (globalDragCounter === 0) {
        imgContainer.style.outline = 'none'
    }
})

document.addEventListener('drop', (e) => {
    globalDragCounter = 0
    imgContainer.style.outline = 'none'
})
</script>
</body>
</html>
